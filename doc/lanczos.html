<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <title>IETL Documentation - lanczos.h</title>                                                                                                                           <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"></head>  <body>                            <h1>IETL library: lanczos.h</h1>              This header implements the Lanczos algorithm without reorthogonalization, as invented by Cullum and Willoughby [<a href="index.html#Ref3">3,4</a>]. This algorithm is quite complex and we recommend the user to study the book by Cullum and Willoughby [<a href="index.html#Ref4">4</a>] on whose Fortran implementation this generic C++ implementation is based.       <ul>                 </ul>                        <h2>Documentation</h2> <h3>Synopsis</h3> <pre>namespace ietl { <br><br>  template &lt;class magnitude_type=double&gt;<br>  class <a href="#The_Lanczos_information_class_Info">Info</a> {<br>  public:<br>    enum errorinfo {ok = 0, no_eigenvalue, not_calculated};      <br>    <br>    Info() {}    <br>    <br>    int m1(int i) const;<br>    int m2(int i) const;<br>    int ma(int i) const;<br>    int size() const;<br>    magnitude_type eigenvalue(int i) const;<br>    magnitude_type residual(int i) const;<br>    errorinfo error_info(int i) const;    <br>  };<br>  <br><br>  template &lt;class VS&gt;<br>  class <a href="#The_T-matrix_class_Tmatrix">Tmatrix</a> {<br>  public:<br>    typedef typename vectorspace_traits&lt;VS&gt;::scalar_type scalar_type; <br>    typedef typename vectorspace_traits&lt;VS&gt;::vector_type vector_type;<br>    typedef typename vectorspace_traits&lt;VS&gt;::magnitude_type magnitude_type;<br>    typedef typename vectorspace_traits&lt;VS&gt;::size_type size_type;<br>    <br>    Tmatrix() {}<br>        <br>    const std::vector&lt;magnitude_type&gt;&amp; eigenvalues(bool discard_ghosts=true) const;<br>    const std::vector&lt;magnitude_type&gt;&amp; errors(bool discard_ghosts=true) const; <br>    const std::vector&lt;int&gt;&amp; multiplicities(bool discard_ghosts=true) const;<br>  };<br><br><br>  template &lt;class MATRIX, class VS&gt;<br>  class <a href="#The_Lanczos_algorithm_class_lanczos">lanczos</a> : public Tmatrix&lt;VS&gt; { <br>  public:<br>    typedef typename vectorspace_traits&lt;VS&gt;::vector_type vector_type;<br>    typedef typename vectorspace_traits&lt;VS&gt;::scalar_type scalar_type;<br>    typedef typename vectorspace_traits&lt;VS&gt;::magnitude_type magnitude_type;<br>    <br>    lanczos(const MATRIX&amp; matrix, const VS&amp; vec);<br>    <br>    template &lt;class IT, class GEN&gt;<br>    void calculate_eigenvalues(IT&amp; iter, GEN gen);<br>    <br>    template &lt;class IT&gt;<br>    void more_eigenvalues(IT&amp; iter);<br><br>    <br>    template &lt;class IN, class OUT, class GEN&gt;<br>    void eigenvectors(IN in_eigvals_start, IN in_eigvals_end , OUT eig_vectors, <br>                      Info&lt;magnitude_type&gt;&amp; info, GEN gen, int maxiter=0);    <br>  };<br>}<br></pre> <h3><a name="The_Lanczos_information_class_Info"></a>The Lanczos information class <tt>Info</tt></h3> The Lanczos information class <tt>Info</tt> is used to return information on eigenvector calculations. It is templated on the <tt>magnitude_type</tt> of the vector space, which defaults to <tt>double</tt>. <pre>  enum errorinfo {ok = 0, no_eigenvalue, not_calculated};      <br></pre> <p>    </p> The <tt>errorinfo</tt> type identifies error codes for eigenvector calculations:<br> <ul>   <li><tt>ok</tt> indicates that the eigenvector was calculated withoutany problems.</li>   <li><tt>no_eigenvalue</tt> indicates that the value for which an eigenvector was requested is not an eigenvalue of the matrix.</li>   <li><tt>not_calculated</tt> indicates that the eigenvector could not be calculated since the maximum number of iterations would be exceeded.  <br>   </li> </ul> <pre>  int m1(int i) const;<br></pre> is the <i>T</i>-matrix size at which the <tt>i</tt>-th eigenvalue has converged for the first time. <br> <pre>  int m2(int i) const;<br></pre> <p>is the <i>T-</i>matrix size at which the <tt>i</tt>-th eigenvalue has convergedfor the second time.&nbsp;</p> <pre>  int ma(int i) const;<br></pre> <p>is the <i>T-</i>matrix size used for the calculation of the <tt>i</tt>-th eigenvector.</p> <pre>  int size() const;<br></pre> <p>is the maximum size of <i>T-</i>matrix calculated by the Lanczos iterations.<br> </p> <pre>    magnitude_type eigenvalue(int i) const;<br></pre> <p>is an improved estimate of the <tt>i</tt>-th eigenvalue<br> </p> <pre>    magnitude_type residual(int i) const;<br></pre> <p>is the residual of the <tt>i</tt>-th eigenvector<br> </p> <pre>    errorinfo error_info(int i) const;  </pre> returns the error code for the calculation of the <tt>i</tt>-th eigenvector.<br> <h3><a name="The_T-matrix_class_Tmatrix"></a>The <i>T</i>-matrix class <tt>Tmatrix</tt></h3> The Lanczos algorithms converts a matrix to a tridiagonal matrix, called the <i>T</i>-matrix, which is stored in the <tt>Tmatrix</tt> class, templated on the <tt>magnitude_type</tt> of the vector space. <pre>    typedef typename vectorspace_traits&lt;VS&gt;::scalar_type scalar_type; <br>    typedef typename vectorspace_traits&lt;VS&gt;::vector_type vector_type;<br>    typedef typename vectorspace_traits&lt;VS&gt;::magnitude_type magnitude_type;<br>    typedef typename vectorspace_traits&lt;VS&gt;::size_type size_type;<br></pre> <p>are typedefs as shortcuts.<br> </p> <pre>    const std::vector&lt;magnitude_type&gt;&amp; eigenvalues(bool discard_ghosts=true) const;<br>    const std::vector&lt;magnitude_type&gt;&amp; errors(bool discard_ghosts=true) const; <br>    const std::vector&lt;int&gt;&amp; multiplicities(bool discard_ghosts=true) const;<br></pre> <p>return vectors containing the eigenvalues, errors and multiplicities of the <i>T</i>-matrix eigenvalues, sorted from lowest to highest eigenvalue. Instead of&nbsp; expensive reorthogonalization the Cullum-Willoughby version of the Lanczos algorithm lives with roundoff errors. After the Lanczos iterations it detects incorrect eigenvalues due to roundoff errors, called ghosts. A <tt>true</tt> argument passed to any of the three functions removes all these spurious eigenvalues.<br> </p> <p>The <tt>errors</tt> of the eigenvalues are calculated for isolated single eigenvalues (multiplicity 1) and give an estimate for the error for all unconverged eigenvalues. Once an eigenvalue appears multiple times it is defined to be converged and the errors are set to 0.<br> </p> <p>The <tt>multiplicities</tt> of the eigenvalues are <b>not</b> the multiplicities of the original matrix but the multiplicities in the <i>T</i>-matrix, which can be larger because of spurious eigenvalues converging to multiple copies of the real one. Spurious eigenvalues (ghosts) are marked by zero multiplicity if not discarded.</p> <div align="center"> <div align="left"> <h3><a name="The_Lanczos_algorithm_class_lanczos"></a>The Lanczos algorithm class <tt>lanczos</tt></h3> <p>The Lanczos algorithm is more complex than the other iterative algorithms and requires two passes of the iterations to calculate the eigenvectors. Inthe first pass the <i>T</i>-matrix is constructed and eigenvalues of the originalmatrix are calculated from the <i>T</i>-matrix. The eigenvectors of the <i>T-</i>matrixare in a different basis than the original matrix and a second pass throughthe iterations is required to transform them back to the original basis.Since information (the <i>T</i>-matrix) needs to be kept from one pass tothe other the Lanczos algorithm is implemented as a class, derived from the<tt>Tmatrix</tt> class. Thus, all member functions of <tt>Tmatrix</tt> arealso accessible to the <tt>lanczos</tt> class.<br> </p> The <tt>lanczos</tt> class is templated on the matrix and vector space types.<br> <pre>  lanczos(const MATRIX&amp; matrix, const VS&amp; vec);<br></pre> <p>The constructor takes a reference to the matrix and the vector space. Sinceonly references are stored inside <tt>lanczos</tt>, the lifetime of theseobjects has to be at least the same as that of the <tt>lanczos</tt> object.</p> <pre>  template &lt;class IT, class GEN&gt;<br>  void calculate_eigenvalues(IT&amp; iter, GEN gen);<br></pre> <p>runs the Lanczos iteration, starting from a random vector generated from the generator <tt>gen</tt> and runs as long as the <a href="interfaces.html#Requirements_on_the_Lanczos_iteration">Lanczos iteration control object</a> <tt>iter</tt> tells it to. Note that the Lanczos iteration control object needs to fulfill other concepts than the basic iteration control object since more than one eigenvalue is calculated. Memory requirements arefor three vectors. After a call to <tt>calculate_eigenvalues</tt> the eigenvaluescan be accessed through the member functions of the <i>T</i>-matrix baseclass.</p> <pre>  template &lt;class IT&gt;<br>  void more_eigenvalues(IT&amp; iter);<br></pre> <p>continues the Lanczos iterations from the last two Lanczos vectors stored in the <tt>lanczos</tt> class.</p> <pre>  template &lt;class IN, class OUT, class GEN&gt;<br>void eigenvectors(IN in_eigvals_start, IN in_eigvals_end , OUT eig_vectors, <br>                  Info&lt;magnitude_type&gt;&amp; info, GEN gen, int maxiter=0);    <br></pre> <p>calculates eigenvectors of the eigenvalues passed by a range of iterators. The memory requirements are for <tt>3+in_eigvals_end-in_eigvals_start</tt> vectors.&nbsp;</p> <p>The eigenvector calculation proceeds by running the Lanczos iterations a second time to convert <i>T</i>-matrix eigenvalues back to the original basis. To initialize this second iteration, the same generator object <tt>gen</tt> used for the eigenvalue calculation needs to be passed.<br> </p> <p>The resulting eigenvectors are copied to the output iterator for vectors <tt>eig_vectors</tt>, and information about <i>T</i>-matrix sizes or convergence problems is passed back in the <tt>info</tt> object.<br> </p> <p>Eigenvector calculation may need a larger size <i>T</i>-matrix than eigenvalue.The implementation estimates the needed size of <i>T</i>-matrix and attemptseigenvector calculation. If no sufficient accuracy is obtained after increasingthe <i>T-</i>matrix by about 50%, the algorithm stops it attempts, does notcaculate the eigenvector and sets the <tt>error_info</tt> for that eigenvaluenot <tt>not_calculated</tt>. If that happens, a larger number of iterationscan be allowed by passing the allowable number of additional iterations inthe optional <tt>maxiter</tt> argument.<br> </p>  <p>  </p> </div> </div>      <hr width="100%" size="2"><br>                     <div align="center">        <address>copyright 2002-2004 by <a href="http://www.itp.phys.ethz.ch/staff/troyer/">Matthias Troyer</a> and<a href="http://www.itp.phys.ethz.ch/staff/prakash/">Prakash Dayal</a><br>   </address>   </div>               <br>              <br>          <br>        <br>      <br>     <br>    <br>   <br>  <br> <br></body></html>